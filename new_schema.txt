create table public.staff (
  id uuid not null default gen_random_uuid (),
  auth_id uuid null,
  first_name text not null,
  middle_name text null,
  last_name text not null,
  birthdate date not null,
  gender text not null,
  address text not null,
  phone_number text not null,
  email_address text not null,
  is_active boolean null default true,
  created_at timestamp without time zone null default CURRENT_TIMESTAMP,
  updated_at timestamp without time zone null default CURRENT_TIMESTAMP,
  updated_by uuid null,
  constraint staff_pkey primary key (id),
  constraint staff_auth_id_key unique (auth_id),
  constraint staff_email_address_key unique (email_address),
  constraint staff_updated_by_fkey foreign KEY (updated_by) references staff (id) on delete set null,
  constraint staff_gender_check check (
    (
      gender = any (array['male'::text, 'female'::text])
    )
  )
) TABLESPACE pg_default;

create index IF not exists idx_staff_is_active on public.staff using btree (is_active) TABLESPACE pg_default;

create index IF not exists idx_staff_auth_id on public.staff using btree (auth_id) TABLESPACE pg_default;

create table public.roles (
  id text not null,
  constraint roles_pkey primary key (id),
  constraint roles_id_check check (
    (
      id = any (
        array[
          'admin'::text,
          'cashier'::text,
          'attendant'::text,
          'rider'::text
        ]
      )
    )
  )
) TABLESPACE pg_default;

create table public.staff_roles (
  staff_id uuid not null,
  role_id text not null,
  constraint staff_roles_pkey primary key (staff_id, role_id),
  constraint staff_roles_role_id_fkey foreign KEY (role_id) references roles (id) on delete CASCADE,
  constraint staff_roles_staff_id_fkey foreign KEY (staff_id) references staff (id) on delete CASCADE
) TABLESPACE pg_default;

create index IF not exists idx_staff_roles_role_id on public.staff_roles using btree (role_id) TABLESPACE pg_default;

create index IF not exists idx_staff_roles_staff_id on public.staff_roles using btree (staff_id) TABLESPACE pg_default;

create table public.customers (
  id uuid not null default gen_random_uuid (),
  auth_id uuid null,
  first_name text not null,
  middle_name text null,
  last_name text not null,
  birthdate date null,
  gender text null,
  address text null,
  phone_number text not null,
  email_address text null,
  loyalty_points integer null default 0,
  created_at timestamp without time zone null default CURRENT_TIMESTAMP,
  updated_at timestamp without time zone null default CURRENT_TIMESTAMP,
  constraint customers_pkey primary key (id),
  constraint customers_auth_id_key unique (auth_id),
  constraint customers_gender_check check (
    (
      gender = any (
        array['male'::text, 'female'::text, 'other'::text]
      )
    )
  )
) TABLESPACE pg_default;

create index IF not exists idx_customers_phone on public.customers using btree (phone_number) TABLESPACE pg_default;

create index IF not exists idx_customers_email on public.customers using btree (email_address) TABLESPACE pg_default;

create index IF not exists idx_customers_auth_id on public.customers using btree (auth_id) TABLESPACE pg_default;

create table public.services (
  id uuid not null default gen_random_uuid (),
  service_type text not null,
  name text not null,
  description text null,
  base_price numeric(10, 2) not null,
  tier text null,
  base_duration_minutes integer null,
  modifiers jsonb null,
  image_url text null,
  sort_order integer null default 0,
  is_active boolean null default true,
  created_at timestamp without time zone null default now(),
  updated_at timestamp without time zone null default now(),
  updated_by uuid null,
  constraint services_pkey primary key (id),
  constraint services_updated_by_fkey foreign KEY (updated_by) references staff (id) on delete set null,
  constraint services_base_duration_minutes_check check ((base_duration_minutes >= 0)),
  constraint services_tier_check check (
    (
      tier = any (array['basic'::text, 'premium'::text])
    )
  ),
  constraint svc_tier_validation check (
    case
      when (
        service_type = any (array['wash'::text, 'dry'::text])
      ) then (tier is not null)
      when (
        service_type = any (
          array[
            'spin'::text,
            'iron'::text,
            'staff_service'::text,
            'pickup'::text,
            'delivery'::text
          ]
        )
      ) then (tier is null)
      else false
    end
  ),
  constraint services_service_type_check check (
    (
      service_type = any (
        array[
          'wash'::text,
          'spin'::text,
          'dry'::text,
          'iron'::text,
          'staff_service'::text,
          'pickup'::text,
          'delivery'::text
        ]
      )
    )
  ),
  constraint services_base_price_check check ((base_price > (0)::numeric))
) TABLESPACE pg_default;

create index IF not exists idx_services_service_type on public.services using btree (service_type) TABLESPACE pg_default;

create index IF not exists idx_services_tier on public.services using btree (tier) TABLESPACE pg_default;

create index IF not exists idx_services_is_active on public.services using btree (is_active) TABLESPACE pg_default;

create index IF not exists idx_services_sort_order on public.services using btree (sort_order) TABLESPACE pg_default;

create trigger trigger_services_updated_at BEFORE
update on services for EACH row
execute FUNCTION update_services_updated_at ();

create table public.products (
  id uuid not null default gen_random_uuid (),
  sku text not null,
  item_name text not null,
  description text null,
  unit_price numeric(10, 2) not null,
  unit_cost numeric(10, 2) not null,
  unit text not null default 'piece'::text,
  quantity numeric(10, 2) not null default 0,
  reorder_level numeric(10, 2) not null default 0,
  image_url text null,
  image_cached_at timestamp without time zone null,
  sort_order integer null default 0,
  is_active boolean null default true,
  created_at timestamp without time zone null default now(),
  updated_at timestamp without time zone null default now(),
  last_stock_check timestamp without time zone null,
  updated_by uuid null,
  constraint products_pkey primary key (id),
  constraint products_sku_key unique (sku),
  constraint products_updated_by_fkey foreign KEY (updated_by) references staff (id) on delete set null,
  constraint products_quantity_check check ((quantity >= (0)::numeric)),
  constraint products_reorder_level_check check ((reorder_level >= (0)::numeric)),
  constraint products_price_check check ((unit_price >= unit_cost)),
  constraint products_unit_cost_check check ((unit_cost >= (0)::numeric)),
  constraint products_unit_price_check check ((unit_price >= (0)::numeric))
) TABLESPACE pg_default;

create index IF not exists idx_products_sku on public.products using btree (sku) TABLESPACE pg_default;

create index IF not exists idx_products_item_name on public.products using btree (item_name) TABLESPACE pg_default;

create index IF not exists idx_products_is_active on public.products using btree (is_active) TABLESPACE pg_default;

create index IF not exists idx_products_quantity_low on public.products using btree (quantity) TABLESPACE pg_default
where
  (
    (quantity <= reorder_level)
    and (is_active = true)
  );

create trigger trigger_products_updated_at BEFORE
update on products for EACH row
execute FUNCTION update_products_updated_at ();

create table public.basket_service_status (
  id uuid not null default gen_random_uuid (),
  order_id uuid not null,
  basket_number integer not null,
  service_type character varying(50) not null,
  status character varying(20) not null default 'pending'::character varying,
  started_at timestamp with time zone null,
  completed_at timestamp with time zone null,
  started_by uuid null,
  completed_by uuid null,
  notes text null,
  created_at timestamp with time zone null default now(),
  updated_at timestamp with time zone null default now(),
  constraint basket_service_status_pkey primary key (id),
  constraint unique_order_basket_service unique (order_id, basket_number, service_type),
  constraint basket_service_status_completed_by_fkey foreign KEY (completed_by) references staff (id),
  constraint basket_service_status_started_by_fkey foreign KEY (started_by) references staff (id),
  constraint basket_service_status_order_id_fkey foreign KEY (order_id) references orders (id) on delete CASCADE,
  constraint valid_service_type check (
    (
      (service_type)::text = any (
        (
          array[
            'wash'::character varying,
            'dry'::character varying,
            'spin'::character varying,
            'iron'::character varying,
            'fold'::character varying
          ]
        )::text[]
      )
    )
  ),
  constraint valid_status check (
    (
      (status)::text = any (
        (
          array[
            'pending'::character varying,
            'in_progress'::character varying,
            'completed'::character varying,
            'skipped'::character varying
          ]
        )::text[]
      )
    )
  )
) TABLESPACE pg_default;

create index IF not exists idx_basket_service_status_order_id on public.basket_service_status using btree (order_id) TABLESPACE pg_default;

create index IF not exists idx_basket_service_status_order_basket on public.basket_service_status using btree (order_id, basket_number) TABLESPACE pg_default;

create index IF not exists idx_basket_service_status_status on public.basket_service_status using btree (status) TABLESPACE pg_default;

create table public.product_transactions (
  id uuid not null default gen_random_uuid (),
  product_id uuid not null,
  order_id uuid null,
  quantity_change integer not null,
  transaction_type text not null default 'adjustment'::text,
  notes text null,
  created_at timestamp with time zone null default now(),
  constraint product_transactions_pkey primary key (id),
  constraint product_transactions_order_id_fkey foreign KEY (order_id) references orders (id) on delete set null,
  constraint product_transactions_product_id_fkey foreign KEY (product_id) references products (id) on delete CASCADE,
  constraint valid_transaction_type check (
    (
      transaction_type = any (
        array[
          'order'::text,
          'adjustment'::text,
          'return'::text,
          'restock'::text,
          'damage'::text
        ]
      )
    )
  )
) TABLESPACE pg_default;

create index IF not exists idx_product_transactions_product_id on public.product_transactions using btree (product_id) TABLESPACE pg_default;

create index IF not exists idx_product_transactions_order_id on public.product_transactions using btree (order_id) TABLESPACE pg_default;

create index IF not exists idx_product_transactions_created_at on public.product_transactions using btree (created_at desc) TABLESPACE pg_default;

create table public.orders (
  id uuid not null default gen_random_uuid (),
  customer_id uuid not null,
  cashier_id uuid null,
  status text not null default 'pending'::text,
  breakdown jsonb not null,
  handling jsonb not null,
  total_amount numeric(10, 2) not null,
  created_at timestamp with time zone null default now(),
  updated_at timestamp with time zone null default now(),
  cancelled_at timestamp with time zone null,
  source text null default 'pos'::text,
  constraint orders_pkey primary key (id),
  constraint orders_cashier_id_fkey foreign KEY (cashier_id) references staff (id) on delete set null,
  constraint orders_customer_id_fkey foreign KEY (customer_id) references customers (id) on delete CASCADE,
  constraint orders_source_check check (
    (source = any (array['pos'::text, 'mobile'::text]))
  ),
  constraint orders_status_check check (
    (
      status = any (
        array[
          'pending'::text,
          'processing'::text,
          'completed'::text,
          'cancelled'::text
        ]
      )
    )
  )
) TABLESPACE pg_default;

create index IF not exists idx_orders_customer_id on public.orders using btree (customer_id) TABLESPACE pg_default;

create index IF not exists idx_orders_cashier_id on public.orders using btree (cashier_id) TABLESPACE pg_default;

create index IF not exists idx_orders_status on public.orders using btree (status) TABLESPACE pg_default;

create index IF not exists idx_orders_created_at on public.orders using btree (created_at desc) TABLESPACE pg_default;

create index IF not exists idx_orders_breakdown_gin on public.orders using gin (breakdown) TABLESPACE pg_default;

create index IF not exists idx_orders_handling_gin on public.orders using gin (handling) TABLESPACE pg_default;

create index IF not exists idx_orders_payment_method on public.orders using gin (((handling -> 'payment_method'::text))) TABLESPACE pg_default;

create index IF not exists idx_orders_delivery on public.orders using gin (((handling -> 'handling_type'::text))) TABLESPACE pg_default;

create index IF not exists idx_orders_customer_date on public.orders using btree (customer_id, created_at desc) TABLESPACE pg_default;

create index IF not exists idx_orders_source on public.orders using btree (source) TABLESPACE pg_default;

create index IF not exists idx_orders_source_date on public.orders using btree (source, created_at desc) TABLESPACE pg_default;

